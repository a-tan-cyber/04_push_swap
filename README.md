*This project has been created as part of the 42 curriculum by amtan.*

# push_swap

## Description

`push_swap` is an algorithmic project: **sort a list of integers using two stacks** (**A** and **B**) and a **very small instruction set**, aiming for the **lowest possible number of operations**.

You are allowed to output only these operations:

* `sa`, `sb`, `ss` (swap top two)
* `pa`, `pb` (push between stacks)
* `ra`, `rb`, `rr` (rotate)
* `rra`, `rrb`, `rrr` (reverse rotate)

The program must:

* print **only** the instruction list (one per line) to **stdout**
* print **`Error\n`** to **stderr** on invalid input (non-integers, overflow, duplicates, etc.)
* print **nothing** if there are no arguments

### Bonus

The bonus adds a second program, **`checker`**, which:

* parses the same input list into stack A
* reads instructions from **stdin** (one per line)
* executes them
* prints **`OK\n`** if A is sorted and B is empty, otherwise **`KO\n`**
* prints **`Error\n`** if an instruction is invalid or input is invalid

---

## Instructions

### Build (mandatory)

```bash
make
```

This produces `./push_swap`.

### Run (mandatory)

```bash
./push_swap 3 2 1
./push_swap "3 2 1"   # quoting works too
```

A common way to validate correctness:

```bash
ARG="3 2 1 0"
./push_swap $ARG | ./checker_linux $ARG
```

### Build (bonus)

```bash
make bonus
```

This produces `./checker`.

### Run (bonus)

Manual mode:

```bash
./checker 3 2 1 0
# type instructions, each followed by ENTER
# then press CTRL+D to end input
```

Pipe mode:

```bash
ARG="3 2 1 0"
./push_swap $ARG | ./checker $ARG
```

### Clean (mandatory)

```bash
make clean   # remove mandatory build artifacts (obj/ and dependency files)
make fclean  # clean + remove the push_swap binary
make re      # full rebuild (fclean + make)
```

### Clean (bonus)

```bash
make clean_bonus   # remove bonus build artifacts (obj_bonus/ and dependency files)
make fclean_bonus  # clean_bonus + remove the checker binary
make re_bonus      # full bonus rebuild (fclean_bonus + make bonus)
```

---

## Implementation Overview

### Input pipeline (shared by `push_swap` and `checker`)

1. **Tokenize** arguments using a whitespace set (spaces + `\t\v\n\f\r`).
2. **`atoi_strict`**: parse each token strictly as a 32-bit signed integer.
3. **Duplicate detection**: copy → sort → scan neighbors.
4. **Ranking (“coordinate compression”)**: convert values into ranks `0..n-1`.

   * This keeps comparisons cheap and makes “min/max” logic straightforward.

### Data structures

* **Doubly-linked list nodes** (`t_node`) storing `rank`.
* **Stacks** (`t_stack`) track `top`, `bottom`, and `size`.

### Operations & recording (mandatory program)

* Stack primitives implement the real mutations: swap / push / rotate / reverse-rotate.
* Public `op_*` wrappers:

  * call the primitive
  * if it actually changed something, append an opcode to an operation buffer
* At the end, the op buffer is printed once.

---

## Sorting Strategy (mandatory)

### 1) Early exit

If stack A is already sorted → print nothing.

### 2) Small sort (N ≤ 5)

* **N=2**: one conditional swap.
* **N=3**: rotate the maximum to the bottom, then swap if needed.
* **N=4/5**: push smallest (and second smallest) to B, sort the remaining 3, then push back.

### 3) Chunk / “Butterfly” sort (N > 5)

This is the main strategy used for 100/500.

High-level idea:

* Push values from A to B in **increasing “windows”** (chunks) of ranks.
* Keep B roughly organized by rotating after some pushes.
* Then bring everything back from B → A by repeatedly moving the current max in B to the top and `pa`.

Tuning:

* A simple chunk size heuristic is used:

  * `delta = n / 20 + 7`

---

## Bonus: checker

### Behavior

* Builds stack A from argv using the same strict validation.
* Reads instructions until EOF (CTRL+D).
* Rejects invalid instructions **including extra spaces** (e.g. `"sa "`, `" sa"`).
* Prints:

  * `OK\n` if sorted A and empty B
  * `KO\n` otherwise
  * `Error\n` on invalid input or instruction

### Input reading

The bonus checker uses **`get_next_line()`** (moved into `libft`) to read from stdin.

---

## Project Structure

```
.
├── Makefile
├── include/
│   └── push_swap.h
├── libft/
│   └── ... + get_next_line.*
├── src/
│   ├── main.c
│   ├── checker/
│   │   ├── checker_main_bonus.c
│   │   └── checker_apply_bonus.c
│   ├── ops/
│   ├── parse/
│   ├── sort/
│   ├── stack/
│   └── utils/
└── (obj/, obj_bonus/ generated by Makefile)
```

---

## Usage Examples

Count operations:

```bash
ARG="4 67 3 87 23"
./push_swap $ARG | wc -l
```

Quick random test:

```bash
ARG="$(python3 - <<'PY'
import random
vals = random.sample(range(-1000000, 1000000), 100)
print(' '.join(map(str, vals)))
PY
)"
./push_swap $ARG | ./checker_linux $ARG
```

---

## Resources

### References

* Stack (abstract data type): [https://en.wikipedia.org/wiki/Stack_(abstract_data_type)](https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29)
* Longest Increasing Subsequence (background for alternative strategies): [https://en.wikipedia.org/wiki/Longest_increasing_subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence)
* Push_swap project notes / overview: [https://www.gibbontech.com/ecole42/push_swap/index.html](https://www.gibbontech.com/ecole42/push_swap/index.html)
* Operation list & general explanation:

  * [https://www.marcioflavio.com/push_swap-the-algorithmic-challenge-of-sorting/](https://www.marcioflavio.com/push_swap-the-algorithmic-challenge-of-sorting/)
* Visualizer (helpful for debugging): [https://vscza.itch.io/push-swap](https://vscza.itch.io/push-swap)

### 42-specific

* The official subject PDF provided by 42 (included in this repository as `en.subject.pdf`).

### How AI was used

I used ChatGPT as a learning and productivity assistant for:

* clarifying 42 Norm constraints and Makefile organization
* explaining stack/linked-list pointer manipulations and edge cases
* discussing sorting approaches (small sort, chunk/butterfly, LIS ideas)
* reviewing my reasoning when debugging issues (valgrind errors, sign-compare warnings)

All final code was written, integrated, and tested by me in this repository, and then iterated based on local compilation, valgrind, and checker results.
